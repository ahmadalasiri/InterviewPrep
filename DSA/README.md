# Data Structures and Algorithms (DSA)

A comprehensive collection of data structures and algorithms implementations with detailed explanations and interview preparation materials.

## üìö Contents

### Interview Preparation

- [Basic Questions](./00-interview-preparation/01-basic-questions.md)
- [Array & String Questions](./00-interview-preparation/02-array-string-questions.md)
- [Linked List Questions](./00-interview-preparation/03-linked-list-questions.md)
- [Tree & Graph Questions](./00-interview-preparation/04-tree-graph-questions.md)
- [Algorithm Questions](./00-interview-preparation/05-algorithm-questions.md)
- [System Design & Problem Solving](./00-interview-preparation/06-problem-solving-questions.md)

### Data Structures

1. **[Arrays & Strings](./01-arrays-strings/)** - Basic operations, sliding window, two pointers
2. **[Linked Lists](./02-linked-lists/)** - Singly, doubly, circular linked lists
3. **[Stacks & Queues](./03-stacks-queues/)** - LIFO and FIFO operations
4. **[Trees](./04-trees/)** - Binary trees, BST, AVL, heaps
5. **[Graphs](./05-graphs/)** - Graph representations, traversals
6. **[Hash Tables](./06-hash-tables/)** - Hash maps, hash sets
7. **[Heaps](./07-heaps/)** - Min heap, max heap, priority queues

### Algorithms

8. **[Sorting Algorithms](./08-sorting/)** - Quick, merge, heap, bubble sort
9. **[Searching Algorithms](./09-searching/)** - Binary search, DFS, BFS
10. **[Dynamic Programming](./10-dynamic-programming/)** - Memoization, tabulation
11. **[Greedy Algorithms](./11-greedy/)** - Optimal substructure problems
12. **[Backtracking](./12-backtracking/)** - Recursive exploration
13. **[Bit Manipulation](./13-bit-manipulation/)** - Bitwise operations

## üéØ Learning Path

### Beginner

1. Start with Arrays & Strings
2. Learn Linked Lists
3. Understand Stacks & Queues
4. Study basic Sorting algorithms
5. Practice Binary Search

### Intermediate

1. Master Trees (Binary Trees, BST)
2. Learn Graph traversals (DFS, BFS)
3. Study Hash Tables
4. Understand Dynamic Programming basics
5. Practice common patterns

### Advanced

1. Advanced DP problems
2. Graph algorithms (Dijkstra, Floyd-Warshall)
3. Advanced trees (AVL, Red-Black, Segment Trees)
4. System design with DSA
5. Competitive programming techniques

## üí° Key Concepts

### Time Complexity

- O(1) - Constant
- O(log n) - Logarithmic
- O(n) - Linear
- O(n log n) - Linearithmic
- O(n¬≤) - Quadratic
- O(2‚Åø) - Exponential

### Space Complexity

- In-place algorithms: O(1)
- Recursive algorithms: O(n) stack space
- DP algorithms: O(n) or O(n¬≤) for memoization

### Common Patterns

1. **Two Pointers** - Array/string problems
2. **Sliding Window** - Subarray problems
3. **Fast & Slow Pointers** - Cycle detection
4. **Merge Intervals** - Interval problems
5. **Cyclic Sort** - Missing numbers
6. **Top K Elements** - Heap problems
7. **Binary Search** - Sorted array problems
8. **DFS/BFS** - Tree/graph traversal
9. **Dynamic Programming** - Optimization problems
10. **Backtracking** - Constraint satisfaction

## üìñ Resources

See [resources.md](./resources.md) for detailed learning materials, books, and online platforms.

## üöÄ Getting Started

```javascript
// Clone and run examples
cd DSA

// For JavaScript examples
node 01-arrays-strings/arrays.js

// For Go examples
go run 01-arrays-strings/arrays.go
```

## üìù Practice Platforms

- LeetCode
- HackerRank
- CodeForces
- TopCoder
- GeeksforGeeks
- InterviewBit

## üéì Interview Tips

1. **Understand the problem** - Ask clarifying questions
2. **Think out loud** - Communicate your thought process
3. **Start with brute force** - Then optimize
4. **Consider edge cases** - Empty input, single element, duplicates
5. **Analyze complexity** - Time and space
6. **Write clean code** - Readable and maintainable
7. **Test your solution** - Walk through with examples

## üìä Problem Difficulty Distribution

- **Easy**: 30% - Basic operations and simple logic
- **Medium**: 50% - Pattern recognition and optimization
- **Hard**: 20% - Advanced algorithms and combinations

Focus on understanding patterns rather than memorizing solutions!
